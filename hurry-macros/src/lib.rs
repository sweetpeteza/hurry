use convert_case::{Case, Casing};
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemImpl};

/// Generates a shorthand macro for types with a `new` method.
///
/// The macro name will be the snake_case version of the type name.
///
/// # Example
/// ```
/// use hurry_macros::shorthand;
///
/// struct MyType {
///     value: i32,
/// }
///
/// #[shorthand]
/// impl MyType {
///     pub fn new(value: i32) -> Self {
///         MyType { value }
///     }
/// }
///
/// // This generates a `my_type!` macro:
/// let x = my_type!(42);
/// ```
#[proc_macro_attribute]
pub fn shorthand(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemImpl);
    
    // Get the type name from the impl block
    let type_name = match &*input.self_ty {
        syn::Type::Path(type_path) => {
            type_path.path.segments.last().map(|seg| &seg.ident)
        }
        _ => None,
    };

    let Some(type_ident) = type_name else {
        return syn::Error::new_spanned(
            &input.self_ty,
            "Shorthand can only be used on impl blocks for named types"
        )
        .to_compile_error()
        .into();
    };

    // Check if there's a `new` method
    let has_new = input.items.iter().any(|item| {
        if let syn::ImplItem::Fn(method) = item {
            method.sig.ident == "new"
        } else {
            false
        }
    });

    if !has_new {
        return syn::Error::new_spanned(
            &input,
            "Shorthand requires a `new` method in the impl block"
        )
        .to_compile_error()
        .into();
    }

    // Convert type name to snake_case for the macro name
    let macro_name = syn::Ident::new(
        &type_ident.to_string().to_case(Case::Snake),
        type_ident.span(),
    );

    // Generate the macro
    let expanded = quote! {
        #input

        /// Shorthand macro for creating a new instance.
        ///
        /// Generated by the `#[shorthand]` attribute.
        #[macro_export]
        macro_rules! #macro_name {
            ($($args:expr),* $(,)?) => {
                #type_ident::new($($args),*)
            };
        }
    };

    TokenStream::from(expanded)
}
